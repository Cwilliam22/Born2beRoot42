Born2beRoot :

Creation de la machine :
- Memory size
- Hard disk
- Hard disk file type
- Storage on physical hard disk
- File location and size
- Choose a disk file => debian-12.8.0-amd64-netinst.iso
- Debian GNU/Linux installer mmenu (BIOS mode)
- ...

Configuration de la machine :
- (CMD) [su -] pour se connecter en tant qu'utilisateur root
	=> C'est quoi un utilisateur root ? 
		=> L'utilisateur root est l'administrateur principal d'un système Linux. Il a tous les privilèges et peut faire absolument tout ce qu'il veut sur le système.
		=> Super utilisateur
		=> Si un utilisateur "normal" (non-root) veut effectuer des actions qui nécessitent des privilèges élevés, il doit utiliser (CMD) [sudo] pour devenir root pendant un instant.
	=> [su -] et [su] sont differents
		=> [su] Cela te permet de te connecter en tant que root, mais sans charger son environnement complet. Certaines variables d'environnement ou configurations peuvent ne pas être chargées.
		=> [su -] Cette commande charge l'environnement complet du root, ce qui inclut des paramètres importants.
	=> C'est quoi exactement l'environnement ?
		=> L'environnement d'un utilisateur sur Linux inclut des informations essentielles qui affectent le comportement de son terminal et des programmes.
- (CMD) [apt-get update -y]
	=> Mettre à jour les informations des paquets
		=> MAJ des listes de paquets disponibles depuis les dépôts.
		=> Elle permet de s'assurer que ton système connaît les dernières versions des paquets disponibles avant de procéder à des installations ou mises à jour. 		
		=> L'option [-y] permet d'accepter automatiquement les demandes de confirmation.
- (CMD) [apt-get upgrade -y]
	=> Mettre à jour tous les paquets installés
		=> MAJ des paquets installés vers les dernières versions disponibles.
		=> [-y] permet également d'accepter automatiquement toutes les confirmations de mise à jour.
- (CMD) [apt install sudo]
	=> Installer sudo
		=> (CMD) [apt install] permet d'installer des paquets depuis les dépôts de ta distribution. 
		=> Ici insatllation de la (CMD) [sudo].
- (CMD) [usermod -aG sudo your_username]
	=> Ajouter l'utilisateur dans le groupe sudo
		=> Cette commande ajoute un utilisateur au groupe sudo. 
		=> Le groupe sudo permet aux membres d'exécuter des commandes avec des privilèges élevés via sudo. 
		=> L'option [-aG] signifie "ajouter à un groupe existant" sans retirer l'utilisateur d'autres groupes.
- (CMD) [getent group sudo]
	=> Voir les utilisateurs du groupe sudo
		=> Renvoie la liste des utilisateurs qui font partie du groupe sudo.
- (CMD) [sudo visudo]
	=> Éditer le fichier sudoers avec visudo
		=> (CMD) [sudo] visudo ouvre le fichier sudoers dans un éditeur de texte sécurisé, généralement vi ou nano (selon la configuration de ton système). 
		=> Le fichier sudoers contrôle qui peut utiliser sudo et avec quels privilèges.
- Ajouter les privilèges à ton utilisateur
	=> Dans le fichier sudoers, ajoutzr une ligne spécifiant les privilèges de ton utilisateur.
		=>  A ceci : # User privilege specification
					 root    ALL=(ALL:ALL) ALL
		=> Rajoutez ceci : your_username    ALL=(ALL) ALL
			=> Cela signifie que ton utilisateur aura la possibilité d'exécuter toutes les commandes en tant que root sur toutes les machines. 
			=> Condition, utiliser [sudo].
			=> ALL : Peut exécuter des commandes depuis n'importe quel terminal.
			=> (ALL) : Peut exécuter des commandes en tant que n'importe quel utilisateur (en particulier root).
			=> ALL : Peut exécuter toutes les commandes (pas de restriction).
- Sauvegarder et quitter l'éditeur visudo
	=> Sur nano [Ctrl + o] (sauvegarder) et [Ctrl + X] (quitter) Then exit and save your sudoers file
Now type sudo reboot in your Virtual Machine to reboot sudo
Type sudo /usr/local/bin/monitoring.sh to execute your script as su (super user)
Type sudo crontab -u root -e to open the crontab and add the rule
Lastly at the end of the crontab, type the following */10 * * * * /usr/local/bin/monitoring.sh this means that every 10 mins, this script will show
	=> Sur vi [wq] (sauvegarder et quitter)
- (CMD) [apt-get install git -y]
	=>  Installer Git
		=> [apt-get] gestionnaire de paquets pour les systèmes basés sur Debian (comme Ubuntu). 
		=> Il est utilisé pour installer, mettre à jour et supprimer des paquets logiciels.
- (CMD) [git --version]
	=> Verification de la version de Git
- (CMD) [sudo apt install openssh-server]
	=> Installer le serveur SSH
		=> Cette commande installe OpenSSH Server.
		=> C'est un logiciel qui permet de créer une connexion sécurisée à distance entre ton ordinateur (client SSH) et ta VM (serveur SSH). 
		=> SSH (Secure Shell) est un protocole qui permet de se connecter à un autre ordinateur de manière sécurisée, en utilisant un réseau non sécurisé (comme Internet).
		=> [sudo] Permet d'exécuter la commande avec les privilèges d'administrateur (root).
		=> [apt] C'est le gestionnaire de paquets de Debian/Ubuntu , utilisé pour installer, mettre à jour et supprimer des logiciels.
		=> [openssh-server] C'est le paquet qui contient le serveur SSH. Il permet à ta VM d'accepter des connexions SSH.
	=> C'est quoi le serveur SSH ?
- (CMD) [sudo systemctl status ssh]
	=> Vérifier l'état du serveur SSH 
		=> Verifie si le serveur fonctionne correctement sur la VM.
		=> [systemctl] C'est un outil de gestion des services système sous Linux. Il permet de démarrer, arrêter, vérifier le statut, ou redémarrer des services comme SSH.
		=> [status] affiche l'etat du service 
- Éditer le fichier de configuration SSH avec vim
	=> (CMD) [sudo vim /etc/ssh/sshd_config]
		=> Cette CMD ouvre le fichier de configuration du serveur SSH (sshd_config) avec Vim.
		=> Ce fichier contient tous les paramètres du serveur SSH (comme les ports utilisés, les méthodes d'authentification, etc.).
		=> [/etc/ssh/sshd_config] est le fichier de configuration du serveur SSH.
		=> Si [vim] ne fonctionne pas utilise [nano].
- Modifier le port SSH dans sshd_config
	=> Modifier la ligne du port.
	=> Trouver la ligne #Port 22.
	=> Modifier cette ligne pour le port 4242.
		=> #Port 22 to this Port 4242
- Vérifier la configuration du port dans sshd_config
	=> (CMD) [sudo grep Port /etc/ssh/sshd_config]
	=> Cette CMD cherche toutes les lignes du fichier /etc/ssh/sshd_config qui contiennent le mot "Port".
- (CMD) [sudo service ssh restart]
	=> Redémarrer le service SSH pour appliquer les changements
		=> Le service SSH doit être redémarré chaque fois qu'une modification est apportée à son fichier de configuration pour que les changements prennent effet.
		=> [service] permet de gérer les services sur un système Linux (démarrer, arrêter, redémarrer, etc.).
		=> [ssh] fait référence au service SSH que l'on veut redemarer.
- (CMD) [sudo apt-get install ufw]
	=> Installer UFW
		=> UFW (Uncomplicated Firewall) est un pare-feu simple et facile à utiliser pour gérer les connexions réseau entrantes et sortantes.
		=> Cette CMD installe le logiciel UFW depuis les dépôts de ta distribution Linux.
- (CMD) [sudo ufw enable]
	=> Actver UFW
		=> Cette CMD active le pare-feu UFW et commence à appliquer les règles définies (par défaut, UFW bloque toutes les connexions entrantes non autorisées).
- (CMD) [sudo ufw status numbered]
	=> Verifier l'etat de UFW
		=> Cette CMD affiche l'état actuel de UFW, y compris toutes les règles configurées.
- (CMD) [sudo ufw allow ssh]
	=> Autoriser les connexions SSH
		=> Cette CMD permet les connexions SSH sur le port par défaut (port 22).
		=> Cela garantit l'acces à la VM via SSH, même après avoir activé UFW.
		=> Sans autorisation SSH + UFW est actif = risques d'etre bloque hors de la VM.
- (CMD) [sudo ufw allow 4242]
	=> Autoriser le port 4242
		=> Autorise les connexions entrantes sur le port 4242.
		=> Garantit que le serveur SSH sera accessible via ce port.
- (CMD) [sudo ufw status numbered]
	=> Verifie les regles configurees
		=> Donne une liste des autorisations.
		=> Affichage de "doublons".
(Doublons)
	- Exemple : 4242 et 4242 (v6) 
	- Ces "doublons" correspondent à des règles distinctes pour les protocoles IPv4 et IPv6.
	- Pour 4242 => Cette règle s'applique uniquement au protocole IPv4.
	- Pour 4242 (v6) => Cette règle s'applique uniquement au protocole IPv6.
		=> À quoi servent chacune de ces règles ?
			Règle IPv4 (4242) :
    		- Permet aux connexions provenant d'appareils utilisant une adresse IPv4 d'accéder à ta machine sur le port 4242.
			Règle IPv6 (4242 v6) :
    		- Permet aux connexions provenant d'appareils utilisant une adresse IPv6 d'accéder à ta machine sur le port 4242.
		=> Assure la compatibilite
		=> Simplifier la gestion
[...]

- (CMD) [sudo systemctl restart ssh] 
	=> Redemarrer le serveur SSH
		=> Cela applique les modifications faites dans le fichier de configuration SSH (/etc/ssh/sshd_config), comme celui du port 4242.
- (CMD) [sudo service sshd status]
	=> Verifie l'etat du service SSH
- Ouvrir sa VM sur iTerm
	=> Go iTerm
	=> ssh your_username@127.0.0.1 -p 4242
	=> exit pour quitter la connexion SSH
- (CMD) [sudo apt-get install libpam-pwquality]
	=> Installer la bibliotheque libpam-pwquality
		=> Cette bibliothèque est utilisée pour imposer des critères de complexité pour les mots de passe.
- (CMD) [sudo vim /etc/pam.d/common-password]
	=> Modifier le fichier /etc/pam.d/common-password (ou nano si vim KO)
- Ajouter ou modifier les parametres PAM
	=> Changer la ligne pour :
		=> password  requisite     pam_pwquality.so  retry=3 minlen=10 ucredit=-1 lcredit=-1 dcredit=-1 maxrepeat=3 reject_username difok=7 enforce_for_root
	=> Save and Exit
- (CMD) [sudo vim /etc/login.defs] (ou nano si vim KO)
	=> Entrer dans le fichier de gestion de login
		=> Changer les parametres suivants : PASS_MAX_DAYS, PASS_MIN_DAYS et PASS_WARN_AGE
		=> PASS_MAX_DAYS 30, PASS_MIN_DAYS 2, PASS_WARN_AGE 7
- (CMD) [sudo reboot]
	=> Rebooter pour save les changements 
- (CMD) [sudo groupadd user42]
	=> Creation d'un groupe 42
- (CMD) [sudo groupadd evaluating]
	=> Creation d'un groupe evaluating
- (CMD) [getent group]
	=> Affiche la liste de tous les groupes existants
		=> Check s'il y a user42 et evaluating
- (CMD) [cut -d: -f1 /etc/passwd]
	=> Lister les utilisateurs 
		=> [/etc/passwd] contient les informations de tous les utilisateurs locaux.
		=> [cut] Il s'agit d'un utilitaire en ligne de commande qui permet de couper ou extraire des parties spécifiques de lignes de texte.
		=> [-d:] spécifie le délimiteur, c'est-à-dire le caractère qui sépare les différents champs de la ligne (ici ":").
		=> [-f1] indique qu’on veut extraire le premier champ de chaque ligne du fichier. 
- (CMD) [sudo adduser new_username]
	=> Ajouter un nouvelle utilisateur (local)
		=> Utilisateur local est specidfique a la machine
- (CMD) [sudo usermod -aG user42 your_username]
	=> Ajouter un utilisateur a un groupe (user42)
- (CMD) [sudo usermod -aG evaluating your_new_username]
	=> Ajouter le nouvel utilisateur a un groupe (evaluating)
- (CMD) [getent group user42]
	=> Verifie que l'utilisateur appartient bien au groupe user42
- (CMD) [getent group evaluating]
	=> Verifie que le nouvelle utilisateur appartient bien au groupe evaluating
- (CMD) [groups your_username]
	=> Affiche les groupes dans utilisateurs
- (CMD) [chage -l your_new_username]
	=> Verifie les regles de mot de passe
- (CMD) [cd ~/../../]
	=> Retout au repertoire racine du systeme a partir du repertoire personnel
		=> (CMD) [cd] changement de repertoire 
		=> [~] represente le repertoire personnel de l'utilisateur.
		=> [/../../] monter de niveau dans l'arborescence des repertoirs (chemin relatif).
- (CMD) [cd var/log]
	=> Entrer dans /var/log
		=> Endroit ou sont stockes les journaux systeme sous Linux
			=> C'est quoi les journaux systeme ?
				=> Ce sont des fichiers où le système d'exploitation et les applications enregistrent des événements, 
				   des messages d’erreur, des alertes ou d’autres informations importantes pour surveiller, 
				   diagnostiquer et maintenir le fonctionnement du système.
				=> Ces journaux sont cruciaux pour les administrateurs système, car ils permettent de comprendre ce 
				   qui se passe sur une machine et d'identifier les problèmes éventuels. Par défaut, les journaux 
				   système sont stockés dans le répertoire /var/log.
- (CMD) [mkdir sudo]
	=> Creer un repertoire sudo
- (CMD) [cd sudo && touch sudo.log]
	=> Entre et cree un fichier sudo.log dans le repertoire sudo
- (CMD) [cd ~/../]
	=> Retour au repertoire initial
		=> Niveau superieur dans l'arborescence 
- (CMD) [sudo nano /etc/sudoers]
	=> Ouvrir le fichier sudoers dans nano
- Configurer certain parametres de securite
	=> (1) Defaults	env_reset
	   (2) Defaults	mail_badpass
	   (3) Defaults	secure_path="/usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/bin"
	   (4) Defaults	badpass_message="Password is wrong, please try again!"
	   (5) Defaults	passwd_tries=3
	   (6) Defaults	logfile="/var/log/sudo/sudo.log"
	   (7) Defaults	log_input, log_output
	   (8) Defaults	requiretty

	=> 1. Réinitialise les variables d'environnement à chaque commande sudo pour éviter les interférences.
	   2. Envoie un e-mail à l'administrateur si quelqu'un entre un mauvais mot de passe avec sudo.
	   3. Définit un chemin sécurisé pour les commandes sudo, garantissant que seules les commandes de répertoires sûrs peuvent être exécutées.
	   4. Affiche ce message si l'utilisateur entre un mot de passe incorrect avec sudo.
	   5. Permet à l'utilisateur d'essayer 3 fois de rentrer le bon mot de passe avant de bloquer l'accès.
	   6. Enregistre toutes les actions sudo dans le fichier /var/log/sudo/sudo.log pour garder une trace.
	   7. Enregistre les entrées et sorties de chaque commande sudo, pour un audit complet.
	   8. Exige qu'un terminal interactif soit utilisé pour les commandes sudo, ce qui empêche les scripts non interactifs de les exécuter.
	   		=> Concerne des executions automatiques de scripts, des connexions SSH en mode non-interactif et attaque a distance

- (CMD) [apt-get install -y net-tools]
	=> Installer net-tools
		=> Ensemble d'outils reseau pour Linux.
		=> Cet ensemble inclut la commande netstat, utilisée pour surveiller les connexions réseau, les interfaces actives, etc.
- (CMD) [cd /usr/local/bin/]
	=> Deplace dans le repertoire /usr/local/bin
		=> Utilise pour stocker des scripts et des programmes personnalises
		=> Pourquoi ce repertoire ?
			=> Tout fichier placé dans /usr/local/bin/ peut être exécuté depuis n’importe où sans avoir à taper son chemin complet.
- (CMD) [touch monitoring.sh]
	=> Cree un fichier vide monitoring.sh
		=> monitoring.sh sera un script de surveillance, où seront ecrit des commandes pour surveiller et enregistrer des informations sur le système.
- (CMD) [chmod 777 monitoring.sh]
	=> Change les permissions du fichier monitoring.sh
		=> Rend le script exécutable, donc il pourra être utilisé sans restriction.
		=> Cependant, accorder des permissions aussi larges peut être un risque de sécurité. 
		=> Une alternative plus sûre serait 755, qui limite les droits d’écriture au propriétaire uniquement.

(Partie script de la config)
- Script => (1) #!/bin/bash
			(2) arc=$(uname -a)
			(3) pcpu=$(grep "physical id" /proc/cpuinfo | sort | uniq | wc -l) 
			(4) vcpu=$(grep "^processor" /proc/cpuinfo | wc -l)
			(5) fram=$(free -m | awk '$1 == "Mem:" {print $2}')
			(6) uram=$(free -m | awk '$1 == "Mem:" {print $3}')
			(7) pram=$(free | awk '$1 == "Mem:" {printf("%.2f"), $3/$2*100}')
			(8) fdisk=$(df -BG | grep '^/dev/' | grep -v '/boot$' | awk '{ft += $2} END {print ft}')
			(9) udisk=$(df -BM | grep '^/dev/' | grep -v '/boot$' | awk '{ut += $3} END {print ut}')
			(10) pdisk=$(df -BM | grep '^/dev/' | grep -v '/boot$' | awk '{ut += $3} {ft+= $2} END {printf("%d"), ut/ft*100}')
			(11) cpul=$(top -bn1 | grep '^%Cpu' | cut -c 9- | xargs | awk '{printf("%.1f%%"), $1 + $3}')
			(12) lb=$(who -b | awk '$1 == "system" {print $3 " " $4}')
			(13) lvmu=$(if [ $(lsblk | grep "lvm" | wc -l) -eq 0 ]; then echo no; else echo yes; fi)
			(14) ctcp=$(ss -Ht state established | wc -l)
			(15) ulog=$(users | wc -w)
			(16) ip=$(hostname -I)
			(17) mac=$(ip link show | grep "ether" | awk '{print $2}')
			(18) cmds=$(journalctl _COMM=sudo | grep COMMAND | wc -l)
			(19) wall "	#Architecture: $arc
				(20) #CPU physical: $pcpu
				(21) #vCPU: $vcpu
				(22) #Memory Usage: $uram/${fram}MB ($pram%)
				(23) #Disk Usage: $udisk/${fdisk}Gb ($pdisk%)
				(24) #CPU load: $cpul
				(25) #Last boot: $lb
				(26) #LVM use: $lvmu
				(27) #Connections TCP: $ctcp ESTABLISHED
				(28) #User log: $ulog
				(29) #Network: IP $ip ($mac)
				(30) #Sudo: $cmds cmd"
 - Mettre ce script dans le fichier monitoring.sh
 (- Copier le script sur nano mais a partir d'une connection SSH (copier coller sur la vm complicado))
- 

Outils :
- Sortir de la VM [cmd]
- Passer en root (connexion complete a l'environnement root) [sudo -i]
- Passer en root [sudo su]
- Verification root [whoami]
- Revenir utilisateur normal [exit]
- [sudo reboot]


